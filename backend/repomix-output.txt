This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
config/cloudinary.js
config/mongodb.js
controllers/cartController.js
controllers/orderController.js
controllers/productController.js
controllers/userController.js
middleware/adminAuth.js
middleware/auth.js
middleware/multer.js
models/categoryModel.js
models/followerModel.js
models/messageModel.js
models/orderModel.js
models/productModel.js
models/roleModel.js
models/storeModel.js
models/storeNotificationModel.js
models/userModel.js
models/userNotificationModel.js
package.json
routes/cartRoute.js
routes/orderRoute.js
routes/productRoute.js
routes/userRoute.js
seedAdmin.js
server.js
vercel.json

================================================================
Files
================================================================

================
File: config/cloudinary.js
================
import {v2 as cloudinary} from "cloudinary"

const connectCloudinary = async ()=>{

    cloudinary.config({
        cloud_name: process.env.CLDN_NAME,
        api_key: process.env.CLDN_API_KEY,
        api_secret: process.env.CLDN_API_SECRET
    })
}

export default connectCloudinary

================
File: config/mongodb.js
================
import mongoose from "mongoose";

const connectDB = async ()=>{
    try {
        await mongoose.connect(process.env.MONGO_URI)
        console.log('✔ Database Connected')
    } catch (error) {
        console.error("❌ Databsse connection failed: ", error.message)
    }
}

export default connectDB

================
File: controllers/cartController.js
================
import userModel from "../models/userModel.js"


const addToCart = async (req, res) => {
    try {
        const { userId, itemId, color } = req.body
        const userData = await userModel.findById(userId)

        let cartData = await userData.cartData

        if (cartData[itemId]) {
            if (cartData[itemId][color]) {
                cartData[itemId][color] += 1
            } else {
                cartData[itemId][color] = 1
            }
        } else {
            cartData[itemId] = {}
            cartData[itemId][color] = 1
        }

        await userModel.findByIdAndUpdate(userId, { cartData })
        res.json({ success: true, message: "Added to Cart" })
    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })
    }
}


// CONTROLLER FUNCTION FOR UPADTING USER CART
const updateCart = async (req, res) => {
    try {
        const { userId, itemId, color, quantity } = req.body
        const userData = await userModel.findById(userId)

        let cartData = await userData.cartData

        cartData[itemId][color] = quantity

        await userModel.findByIdAndUpdate(userId, { cartData })
        res.json({ success: true, message: "Cart Updated" })

    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })

    }
}


// CONTROLLER FUNCTION FOR GETTING USER CART DATA
const getUserCart = async (req, res) => {
    try {
        const { userId } = req.body
        const userData = await userModel.findById(userId)

        let cartData = await userData.cartData
        res.json({ success: true, cartData })
    } catch (error) {

        console.log(error)
        res.json({ success: false, message: error.message })
    }
}

export { addToCart, updateCart, getUserCart }

================
File: controllers/orderController.js
================
// import orderModel from "../models/orderModel.js"
// import userModel from "../models/userModel.js"
// import Stripe from 'stripe'


// const currency = "pkr"
// const deliveryCharges = 10

// const stripe = new Stripe(process.env.STRIPE_SECRET_KEY)


// // CONTROLLER FUNCTION FOR PLACING ORDER USING COD METHOD
// const placeOrder = async (req, res) => {
//     try {
//         const { userId, items, amount, address } = req.body

//         const orderData = {
//             userId,
//             items,
//             amount,
//             address,
//             paymentMethod: "COD",
//             payment: false,
//             date: Date.now()
//         }

//         const newOrder = new orderModel(orderData)
//         await newOrder.save()

//         await userModel.findByIdAndUpdate(userId, { cartData: {} })

//         res.json({ success: true, message: "Order Placed" })

//     } catch (error) {
//         console.log(error)
//         res.json({ success: false, message: error.message })
//     }
// }


// // CONTROLLER FUNCTION FOR PLACING ORDER USING STRIPE METHOD
// const placeOrderStripe = async (req, res) => {
//     try {
//         const { userId, items, amount, address } = req.body
//         const { origin } = req.headers

//         const orderData = {
//             userId,
//             items,
//             amount,
//             address,
//             paymentMethod: "Stripe",
//             payment: false,
//             date: Date.now()
//         }

//         const newOrder = new orderModel(orderData)
//         await newOrder.save()

//         const line_items = items.map((item) => ({
//             price_data: {
//                 currency: currency,
//                 product_data: {
//                     name: item.name
//                 },
//                 unit_amount: item.price * 100 * 277 // converting into pkr currency
//             },
//             quantity: item.quantity
//         }))
//         line_items.push({
//             price_data: {
//                 currency: currency,
//                 product_data: {
//                     name: 'Delivery charges'
//                 },
//                 unit_amount: deliveryCharges * 100 * 277
//             },
//             quantity: 1
//         })

//         const session = await stripe.checkout.sessions.create({
//             success_url: `${origin}/verify?success=true&orderId=${newOrder._id}`,
//             cancel_url: `${origin}/verify?success=false&orderId=${newOrder._id}`,
//             line_items,
//             mode: 'payment'
//         })
//         res.json({ success: true, session_url: session.url })

//     } catch (error) {
//         console.log(error)
//         res.json({ success: false, message: error.message })
//     }
// }

// // CONTROLLER FUNCTION FOR VERIFYING STRIPE (THIS IS A TEMPORARY METHOD FOR TEST )
// const verifyStripe = async (req, res) => {
//     const { orderId, success, userId } = req.body

//     try {
//         if (success === "true") {
//             await orderModel.findByIdAndUpdate(orderId, { payment: true })
//             await userModel.findByIdAndUpdate(userId, { cartData: {} })
            
//             res.json({success: true})
//         } else {
//             await orderModel.findByIdAndDelete(orderId)
//             res.json({success:false})
//         }
//     } catch (error) {
//         console.log(error)
//         res.json({ success: false, message: error.message })

//     }
// }



// // CONTROLLER FUNCTION FOR GETTING ALL ORDERS DATA FOR ADMIN PANEL
// const allOrders = async (req, res) => {
//     try {
//         const orders = await orderModel.find({})
//         res.json({ success: true, orders })
//     } catch (error) {
//         console.log(error)
//         res.json({ success: false, message: error.message })
//     }

// }


// // CONTROLLER FUNCTION FOR GETTING USER ORDERS DATA FOR FRONTEND
// const userOrders = async (req, res) => {
//     try {
//         const { userId } = req.body

//         const orders = await orderModel.find({ userId })
//         res.json({ success: true, orders })
//     } catch (error) {
//         console.log(error)
//         res.json({ success: false, message: error.message })
//     }
// }



// // CONTROLLER FUNCTION FOR UPDATING USER ORDER STATUS
// const updateStatus = async (req, res) => {
//     try {
//         const { orderId, status } = req.body

//         await orderModel.findByIdAndUpdate(orderId, { status })
//         res.json({ success: true, message: "Status Updated" })
//     } catch (error) {

//         console.log(error)
//         res.json({ success: false, message: error.message })
//     }
// }

// export { placeOrder, placeOrderStripe, allOrders, userOrders, updateStatus, verifyStripe }

================
File: controllers/productController.js
================
import { v2 as cloudinary } from "cloudinary"
import productModel from "../models/productModel.js";


const addProduct = async (req, res) => {
    try {
        const { name, description, price, category, colors, popular } = req.body

        const image1 = req.files?.image1?.[0];
        const image2 = req.files?.image2?.[0];
        const image3 = req.files?.image3?.[0];
        const image4 = req.files?.image4?.[0];

        const images = [image1, image2, image3, image4].filter((item) => item !== undefined)
        let imagesUrl;
        if (images.length > 0) {
            imagesUrl = await Promise.all(
                images.map(async (item) => {
                    const result = await cloudinary.uploader.upload(item.path, { resource_type: "image" })
                    return result.secure_url
                })
            )
        } else {
            imagesUrl = ['https://via.placeholder.com/150']
        }
        const productData = {
            name,
            description,
            price,
            category,
            popular: popular == "true" ? true : false,
            colors: colors ? JSON.parse(colors) : [], 
            image: imagesUrl,
            date: Date.now()
        }

        console.log(productData)

        const product = new productModel(productData)
        await product.save()

        res.json({ success: true, message: "Product Added" })
    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })
    }
}

const removeProduct = async (req, res) => {
    try {
        await productModel.findByIdAndDelete(req.body.id)
        res.json({ success: true, message: "Product Removed" })
    } catch (error) {

        console.log(error)
        res.json({ success: false, message: error.message })
    }
}


const listProducts = async (req, res) => {
    try {
        const products = await productModel.find({})
        res.json({ success: true, products })
    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })

    }
}

const singleProduct = async (req, res) => {
    try {
        const { productId } = req.body
        const product = await productModel.findById(productId)
        res.json({ success: true, product })

    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })

    }
}

export { addProduct, removeProduct, listProducts, singleProduct }

================
File: controllers/userController.js
================
import userModel from "../models/userModel.js";
import roleModel from "../models/roleModel.js"; // Import the Role model
import bcrypt from "bcrypt";
import validator from "validator";
import jwt from "jsonwebtoken";

const createToken = (id) => {
    return jwt.sign({ id }, process.env.JWT_SECRET);
};

// Regular user login
const loginUser = async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await userModel.findOne({ email });
        if (!user) {
            return res.json({ success: false, message: "User doesn't exist" });
        }
        const isMatch = await bcrypt.compare(password, user.password);
        if (isMatch) {
            const token = createToken(user._id);
            res.json({ success: true, token });
        } else {
            res.json({ success: false, message: "Invalid Credentials" });
        }
    } catch (error) {
        console.log(error);
        res.json({ success: false, message: error.message });
    }
};

// Regular user registration; always assigns the "user" role
const registerUser = async (req, res) => {
    try {
        const { name, email, password } = req.body;
        const exists = await userModel.findOne({ email });
        if (exists) {
            return res.json({ success: false, message: "User already exists" });
        }
        if (!validator.isEmail(email)) {
            return res.json({ success: false, message: "Please enter a valid email" });
        }
        if (password.length < 8) {
            return res.json({ success: false, message: "Please enter a strong password" });
        }

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        // Look up the "user" role. Create it if it doesn't exist.
        let userRole = await roleModel.findOne({ roleName: "user" });
        if (!userRole) {
            userRole = await roleModel.create({ roleName: "user" });
        }

        const newUser = new userModel({
            name: name,
            email: email,
            password: hashedPassword,
            roleId: userRole._id, // assign the "user" role
        });

        const user = await newUser.save();
        const token = createToken(user._id);
        res.json({ success: true, token });
    } catch (error) {
        console.log(error);
        res.json({ success: false, message: error.message });
    }
};

// Admin login: verifies that the account exists, password matches, and the role is "admin"
const adminLogin = async (req, res) => {
    try {
        const { email, password } = req.body;
        const adminUser = await userModel.findOne({ email });
        if (!adminUser) {
            return res.json({ success: false, message: "Admin not found" });
        }
        const isMatch = await bcrypt.compare(password, adminUser.password);
        if (!isMatch) {
            return res.json({ success: false, message: "Invalid Credentials" });
        }
        // Verify role
        const role = await roleModel.findById(adminUser.roleId);
        if (role.roleName !== "admin") {
            return res.json({ success: false, message: "Not an admin account" });
        }
        const token = createToken(adminUser._id);
        res.json({ success: true, token });
    } catch (error) {
        console.log(error);
        res.json({ success: false, message: error.message });
    }
};

export { loginUser, registerUser, adminLogin };

================
File: middleware/adminAuth.js
================
import jwt from "jsonwebtoken"

const adminAuth = async (req, res, next) => {
    try {
        const { token } = req.headers
        if (!token) {
            return res.json({ success: false, message: "Not Authorized Login again" })
        }
        const token_decode = jwt.verify(token, process.env.JWT_SECRET)

        if (token_decode !== process.env.ADMIN_EMAIL + process.env.ADMIN_PASS) {
            return res.json({ success: false, message: "Not Authorized Login again" })
        }
        next()
    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })
    }
}

export default adminAuth

================
File: middleware/auth.js
================
import jwt from "jsonwebtoken"

const authUser = async (req, res, next) => {
    const { token } = req.headers

    if (!token) {
        return res.json({ success: false, message: "Not Authorized Please Login again" })
    }
    try {
        const token_decode = jwt.verify(token, process.env.JWT_SECRET)
        req.body.userId = token_decode.id
        next()
    } catch (error) {
        console.log(error)
        res.json({ success: false, message: error.message })
    }
}

export default authUser

================
File: middleware/multer.js
================
import multer from "multer";

const storage = multer.diskStorage({
    filename: function (req, file, callback) {
        callback(null, file.originalname)
    }
})

const upload = multer({ storage })

export default upload

================
File: models/categoryModel.js
================
import mongoose from "mongoose";

const categorySchema = new mongoose.Schema(
  {
    categoryName: {
      type: String,
      required: true,
      unique: true,
    },
  },
  { timestamps: true }
);

export default mongoose.model("Category", categorySchema);

================
File: models/followerModel.js
================
import mongoose from "mongoose";

const followerSchema = new mongoose.Schema(
  {
    // Relationship to User
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    // Relationship to Store
    storeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Store",
      required: true,
    },
  },
  { timestamps: true }
);

export default mongoose.model("Follower", followerSchema);

================
File: models/messageModel.js
================
import mongoose from "mongoose";

const messageSchema = new mongoose.Schema(
  {
    content: {
      type: String,
      required: true,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
    isRead: {
      type: Boolean,
      default: false,
    },
    senderType: {
      type: String,
      enum: ["user", "store", "admin"],
      required: true,
    },
    // Relationship to UserNotification (if each message belongs to a notification)
    userNotificationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "UserNotification",
    },
  },
  { minimize: false }
);

export default mongoose.model("Message", messageSchema);

================
File: models/orderModel.js
================
import mongoose from "mongoose"

const orderSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        required: true,
      },
      storeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Store",
        required: true,
      },
    items: { type: Array, required: true },
    amount: { type: Number, required: true },
    address: { type: Object, required: true },
    status: { type: String, required: true, default: "Order Placed" },
    paymentMethod: { type: String, required: true },
    payment: { type: Boolean, required: true, default: false },
    date: { type: Number, required: true },
   
    

})

const orderModel = mongoose.models.order || mongoose.model('order', orderSchema)

export default orderModel

================
File: models/productModel.js
================
import mongoose from "mongoose";

const productSchema = new mongoose.Schema({
    categoryId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Category",
        required: true,
      },
      storeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Store",
        required: true,
      },
      createdAt: {
        type: Date,
        default: Date.now,
      },
    name:{type:String, required:true},
    description:{type:String, required:true},
    price:{type:Number, required:true},
    image:{type:Array, required:true},
    category:{type:String, required:true},
    colors:{type:Array, required:true},
    popular:{type:Boolean},
    date:{type:Number, required:true},
})

const productModel = mongoose.models.product || mongoose.model("product", productSchema)

export default productModel

================
File: models/roleModel.js
================
import mongoose from "mongoose";

const roleSchema = new mongoose.Schema(
  {
    roleName: {
      type: String,
      required: true,
      unique: true, // e.g. 'admin', 'user', etc.
    },
  },
  { timestamps: true }
);

export default mongoose.model("Role", roleSchema);

================
File: models/storeModel.js
================
import mongoose from "mongoose";

const storeSchema = new mongoose.Schema(
  {
    storeName: {
      type: String,
      required: true,
    },
    storeAddress: {
      type: String,
      required: false,
    },
  },
  { timestamps: true }
);

export default mongoose.model("Store", storeSchema);

================
File: models/storeNotificationModel.js
================
import mongoose from "mongoose";

const storeNotificationSchema = new mongoose.Schema(
  {
    // Relationship to Store
    storeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Store",
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  { minimize: false }
);

export default mongoose.model("StoreNotification", storeNotificationSchema);

================
File: models/userModel.js
================
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    cartData: { type: Object, default: {} },
    
}, { minimize: false })

const userModel = mongoose.models.user || mongoose.model("user", userSchema)

export default userModel

================
File: models/userNotificationModel.js
================
import mongoose from "mongoose";

const userNotificationSchema = new mongoose.Schema(
  {
    // Relationship to User
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    // Relationship to Store (optional if needed by your logic)
    storeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Store",
    },
    // Relationship to Order (optional if needed by your logic)
    orderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
    },
  },
  { timestamps: true }
);

export default mongoose.model("UserNotification", userNotificationSchema);

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "server": "nodemon server.js"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cloudinary": "^2.5.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.9.3",
    "multer": "^1.4.5-lts.1",
    "nodemon": "^3.1.9",
    "stripe": "^17.5.0",
    "validator": "^13.12.0"
  }
}

================
File: routes/cartRoute.js
================
import express from "express"
import { addToCart, getUserCart, updateCart } from "../controllers/cartController.js"
import authUser from "../middleware/auth.js"

const cartRouter = express.Router()

cartRouter.post('/add', authUser, addToCart)
cartRouter.post('/get', authUser, getUserCart)
cartRouter.post('/update', authUser, updateCart)

export default cartRouter

================
File: routes/orderRoute.js
================
// import express from "express"
// import adminAuth from "../middleware/adminAuth.js"
// import { allOrders, placeOrder, placeOrderStripe, updateStatus, userOrders, verifyStripe } from "../controllers/orderController.js"
// import authUser from "../middleware/auth.js"

// const orderRouter = express.Router()

// // FOR ADMIN
// orderRouter.post('/list', adminAuth, allOrders)
// orderRouter.post('/status', adminAuth, updateStatus)

// // FOR PAYMENT 
// orderRouter.post('/place', authUser, placeOrder)
// orderRouter.post('/stripe', authUser, placeOrderStripe)

// // FOR USER
// orderRouter.post('/userorders', authUser, userOrders)

// // VERIFY STRIPE METHOD
// orderRouter.post('/verifyStripe', authUser, verifyStripe)

// export default orderRouter

================
File: routes/productRoute.js
================
import express from "express"
import { addProduct, listProducts, removeProduct, singleProduct } from "../controllers/productController.js"
import upload from "../middleware/multer.js"
import adminAuth from "../middleware/adminAuth.js"

const productRouter = express.Router()

productRouter.post("/add",adminAuth, upload.fields([{name:'image1', maxCount:1},{name:'image2', maxCount:1},{name:'image3', maxCount:1},{name:'image4', maxCount:1}]), addProduct)
productRouter.post("/remove",adminAuth, removeProduct)
productRouter.post("/single", singleProduct)
productRouter.get("/list", listProducts)

export default productRouter

================
File: routes/userRoute.js
================
import express from "express"
import { adminLogin, loginUser, registerUser } from "../controllers/userController.js"

const userRouter = express.Router()

userRouter.post('/register', registerUser)
userRouter.post('/login', loginUser)
userRouter.post('/admin', adminLogin)

export default userRouter

================
File: seedAdmin.js
================
// seedAdmin.js
import roleModel from "./models/roleModel.js";
import userModel from "./models/userModel.js";
import bcrypt from "bcrypt";

async function seedAdmin() {
  try {
    // 1) Check or create the "admin" role
    let adminRole = await roleModel.findOne({ roleName: "admin" });
    if (!adminRole) {
      adminRole = await roleModel.create({ roleName: "admin" });
      console.log("✔ Admin role created.");
    }

    // 2) Check or create the single admin user
    const adminEmail = process.env.ADMIN_EMAIL; // e.g. "admin@underdogs.com"
    const adminPass = process.env.ADMIN_PASS;   // e.g. "admin123"

    let adminUser = await userModel.findOne({ email: adminEmail });
    if (!adminUser) {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(adminPass, salt);

      adminUser = await userModel.create({
        name: "Administrator",
        email: adminEmail,
        password: hashedPassword,
        roleId: adminRole._id, // Link to the "admin" role
      });
      console.log("✔ Admin user created.");
    } else {
      console.log("Admin user already exists.");
    }
  } catch (error) {
    console.error("Error seeding admin user:", error.message);
  }
}

export default seedAdmin;

================
File: server.js
================
import express from "express"
import cors from "cors"
import "dotenv/config"
import connectDB from "./config/mongodb.js"
import connectCloudinary from "./config/cloudinary.js"
import userRouter from "./routes/userRoute.js"
import productRouter from "./routes/productRoute.js"
import cartRouter from "./routes/cartRoute.js"
// import orderRouter from "./routes/orderRoute.js"
import seedAdmin from "./seedAdmin.js"
// App Config
const app = express()
const port = process.env.PORT || 4000
connectDB().then(() => {
    seedAdmin();
  });
  connectCloudinary()

// Middlewares
app.use(express.json())
app.use(cors())


app.use('/api/user', userRouter)
app.use('/api/product', productRouter)
app.use('/api/cart', cartRouter)
// app.use('/api/order', orderRouter)

app.get('/', (req, res)=>{
    res.send('API Working')
})

app.listen(port, ()=> console.log("Server is running on PORT : "+ port))

================
File: vercel.json
================
{
    "version": 2,
    "builds": [
        {
            "src": "server.js",
            "use": "@vercel/node",
            "config": {
                "includeFiles": [
                    "dist/**"
                ]
            }
        }
    ],
    "routes": [
        {
            "src": "/(.*)",
            "dest": "server.js"
        }
    ]
}



================================================================
End of Codebase
================================================================
